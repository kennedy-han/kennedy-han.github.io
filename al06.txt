根据结论反推算法复杂度

追求速度用快排，常数时间优异，基于实验验证
稳定性，用归并
额外空间少，选堆拍

遇到贱题，用嗷嗷待哺的眼神看着他，对他说面试官这道题我不会，请你讲给我，我等他这个答案等了十年了，求求你了（他马上疯，因为他也不会）

常见的坑 01 stable sort

工程上对排序的改进：

1. 稳定性的考虑
Java中 Arrays.sort() 事实
他做反射判断，如果传入的是基础类型，用快排，因为基础类型不要稳定性
如果是非基础类型，用归并，保证稳定性

面试官说分析一个别的事实，往稳定性这方面想

2. 充分利用O(n log n)和 O(n^2)排序的各自的优势
有些语言快排实现
if( L + 60 > R ){
  // 执行插入排序
  return;
}
否则执行快排

快排指标好，但是常数项不好
插入排序指标不好，常数项优于快排
所以当数量非常小的时候，插入排序的性能优于快排
这样的改进，结合插入排序数据量非常小的优势 和 快排数据量大的调度优势
60是实验出来的，魔数

如果单纯求一个排序的话，并不需要掌握这么多排序算法，但是每种排序算法的思想，能够解决其他别的题，足够引起重视

作业：
单链表
1. 奇数个链表，返回中点 a b c d e 返回 c
偶数个链表，返回上中点 a b c d 返回b
2. 偶数个链表，返回下中点 a b c d 返回c
3. 奇、偶链表，返回中点、上中点的前一个节点
4. 奇偶链表，返回中点、下中点的前一个节点

不要用容器，只用有限几个变量完成

判断链表是否有环，用容器：hashSet

二叉树，先序、中序、后序
递归函数，遍历次数3次，任何回到自己的次序他都有，所以能加工出所有的次序来

递归栈的内存很小，自己做的栈占使用的不是系统栈内存，而是内存空间，内存空间分个32G 64G很正常，系统栈往往就200m-300m
生产环境不允许递归函数出现，由递归改非递归是一个非常重要的能力
有限的递归可以，往往实际运行中，控制不了递归开的层数

附加题：
x祖先节点 交集
先序：头左右
后续：左右头

先序∩后续，都存在头

考虑x作为左树姿态，的右树兄弟们节点
x作为左节点，先序遍历 头左右，右节点在X后面
所以 A X B 集合中，A集合不存在右节点

考虑x作为右树姿态，的左树兄弟们节点
x作为右节点，先序遍历 头左右，左节点的确会出现在X前面
所以 A X B 集合中，A集合会出现左树兄弟节点
再看后续遍历，左右头，因为X作为右节点，所有的左兄弟都会出现在X之前
也就是所有的左兄弟节点，不在A X B 这个B集合里

所以，只有祖先节点会出现在 A ∩ B 里

作业：如何用一个栈实现后序遍历

---
无递归，中序：
整棵树所有节点，是可以被子树左边界分解掉的

---
贪心：
是人类最自然的智慧
面对当前状况选个最优的
然后看看我考虑的东西发生什么变化，再选择第二个
每一步选择局部最优解，但是这个局部最优解，未必是全局最优解
如果它不是，就无效，是就有效

贪心策略，只要能试出来，不用管证明，用对数器证明


剪枝：
17，1‘47，Set过滤
递归跑过了所有的分支，最后一步用了set去过滤
在递归发生之前就检查，如果走过a的分支，如果还来到a分支，提前杀死，快，剪枝策略，不用跑后续的分支策略
过滤是没有省去所有的情况，所有情况发生了
提前杀死省去走很多路，快速


动态规划：
写出一个最基本的尝试，然后一步一步的做缓存
分析位置依赖，
最初的尝试，尝试策略就是状态转移方程
状态转移只是结果，不是原因
非常强调尝试，尝试是自然智慧
动态规划最终优化的版本只是结果
最初的尝试不知道怎么试，哪来的状态转移？


有序表：
数据库索引
任何被做索引的字段，都是可排序的
搜索二叉树，高度过高不好，用户输入的数据 1 2 3 4 ... 导致高度过高，还不如硬盘检索快
时间复杂度按最坏情况估计，用户的输入最难受的就是 1 2 3 4...顺序建立树

平衡搜索二叉树，最高的高度，最好也是log N 

为什么不用hash，O(1)，因为不能范围查询，比如以ABC开头的数据

通过左旋、右旋，减少树的高度，让树变平一点
左旋：谁往哪边倒，就是它右孩子上来

所有树的平衡性不一样，但不管是哪种树，都可以保证，增删改查O(logN)
AVL树：最严格的平衡性
任何一个节点，左树的高度和右树的高度差，不超过1（<2)
